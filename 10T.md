# 10. درخت ریشه‌دار

## خواسته سوال

درختی ریشه‌دار با `n` رأس و وزن‌های اولیه روی هر رأس داده شده است. سپس `q` عملیات به صورت `(v, w)` داریم که وزن رأس `v` را به `w` تغییر می‌دهند. بعد از هر به‌روزرسانی، باید مجموع وزن بیشینه‌ی یک مجموعه‌ی مستقل روی کل درخت را گزارش کنیم.

**ورودی‌ها:**
- عدد صحیح `n`

- `n-1` یال غیر‌جهت‌دار که درخت را می‌سازند

- `n` عدد وزن اولیه‌ی هر رأس

- عدد صحیح `q`

- `q` خط هر کدام دو عدد `(v, w)`


**خروجی:**
- بعد از هر عملیات، بیشینه‌ی وزن مجموعه‌ی مستقل روی درخت  

## راه حل

### تعریف dp

دو آرایه $dp0$ و $dp1$ را برای هر راس $v$ به شکل زیر تعریف می کنیم:

$$dp0[v] = \sum_{u \in \mathrm{children}(v)} \max\bigl(dp0[u],\,dp1[u]\bigr)$$

$$dp1[v] = val[v] + \sum_{u \in \mathrm{children}(v)} dp0[u]$$

### مقداردهی اولیه

با یک DFS از ریشه (مثلاً رأس $1$):

والد و فرزندان هر رأس را تعیین می‌کنیم.

در حالت پس‌گرد (post-order)، مقادیر `dp0` و `dp1` را محاسبه می‌کنیم.

### به‌روزرسانی وزن و پاسخ‌گویی

پس از هر بار که `val[v]` تغییر کرد:
از رأس `v` تا ریشه بالا می‌رویم.  

برای هر رأس $u$ در مسیر، مجدداً مقادیر dp ها را آپدیت می کنیم.

$$dp1[u] = val[x] + \sum_{u \in \mathrm{children}(x)} dp0[u]$$

$$dp0[u] = \sum_{u \in \mathrm{children}(x)} \max(dp0[u],\,dp1[u])$$

در پایان پاسخ مسئله اینگونه به دست می آید.

$$\max\bigl(dp0[1],dp1[1]\bigr)$$

## پیچیدگی زمانی و حافظه

**پیچیدگی زمانی:**

$$O(n + q \cdot n)$$

**پیچیدگی حافظه:**

$$O(n)$$
