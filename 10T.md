# توضیح کد سوال ۱۰

این کد برای حل مسئله‌ای نوشته شده است که در آن یک درخت با n رأس داده شده و به هر رأس مقداری نسبت داده شده است. سپس چندین کوئری (پرس‌وجو) وجود دارد که در هر کدام مقدار یک رأس تغییر می‌کند و باید بیشترین مجموع ممکن از مقادیر رأس‌هایی را پیدا کنیم که به صورت مستقل (یعنی بدون وجود یال بین هیچ دو رأسی از آن‌ها) انتخاب شده‌اند.

## تعریف مفاهیم

### زیرگراف مستقل
زیرگرافی از گراف اصلی است که در آن هیچ یالی بین رأس‌های انتخاب شده وجود ندارد. در این مسئله، هدف انتخاب رأس‌هایی با بیشترین مجموع مقدار است که مستقل باشند.

## ساختار داده‌ها

- `G[v]`: لیستی از همسایه‌های رأس `v` در درخت.
- `chld[v]`: لیستی از فرزندان رأس `v` برای استفاده در برنامه‌نویسی پویا.
- `val[v]`: مقدار (وزن) رأس `v`.
- `dp1[v]`: بیشترین مقدار ممکن اگر رأس `v` انتخاب شود.
- `dp0[v]`: بیشترین مقدار ممکن اگر رأس `v` انتخاب نشود.
- `par[v]`: پدر رأس `v` در درخت.
- `mark[v]`: علامت‌گذاری برای جلوگیری از بازدید دوباره در DFS.

## تابع `upd(v)`

با استفاده از فرزندان `v` مقدارهای `dp0` و `dp1` را آپدیت می‌کند:
- اگر `v` انتخاب شود (`dp1`): فرزندان نباید انتخاب شوند ⇒ `val[v] + sum(dp0[u])`
- اگر `v` انتخاب نشود (`dp0`): فرزندان می‌توانند انتخاب شوند یا نه ⇒ `sum(max(dp0[u], dp1[u]))`

## تابع `DFS(v)`

یک DFS از ریشه انجام می‌دهد و ضمن پر کردن آرایه‌ی `par` و `chld`، مقادیر DP را نیز از برگ‌ها به بالا محاسبه می‌کند.

## بخش `main`

1. خواندن ورودی و ساخت درخت.
2. خواندن مقادیر رأس‌ها.
3. اجرای DFS از رأس ۱ برای پر کردن `dp0` و `dp1`.
4. پاسخ دادن به `q` کوئری:
   - مقدار رأس `v` را تغییر می‌دهد.
   - سپس به صورت بازگشتی از `v` تا ریشه، مقادیر `dp` را با استفاده از `upd()` به‌روز می‌کند.
   - بیشینه مقدار بین `dp0[1]` و `dp1[1]` (یعنی ریشه) را چاپ می‌کند.

## نکته‌ی مهم

درخت بودن گراف باعث می‌شود که این استراتژی به درستی کار کند، زیرا مسیر یکتا بین هر دو رأس وجود دارد و با بروزرسانی از پایین به بالا، تنها نیاکان تغییر یافته نیاز به آپدیت دارند.


