# 2. گراف جادویی

## خواسته سوال
در این مسأله یک گراف بدون دور (جنگل) با $n$ راس و $m$ یال داریم که هر یال دو مقدار «هزینه» و «ارزش جادویی» دارد. باید زیرمجموعه‌ای از یال ها را طوری انتخاب کنیم که:

مجموع هزینه‌های  یالهای انتخابی از حد $b$ کمتر شود.

زیر‌گراف حاصل از یالهای انتخابی همچنان جنگل (بدون دور) باقی بماند.

مجموع ارزش جادویی یالهای انتخابی حداکثر شود.


**ورودی:**

دو عدد صحیح `n` و `m`

در `m` خط بعدی 4 عدد `v` `u` `cost` و `magic` دریافت می شود که به ترتیب بیانگر دو سر یال و هزینه و ارزش جادویی آن است.

یک عدد صحیح `b` (حداکثر بودجه مجاز)  


**خروجی:**

بیشینه مجموع ارزش جادویی ممکن زیرمجموعه‌ای از یالهای با مجموع هزینه کمتر `b`


## راه حل

### مدل‌سازی به‌صورت مسئله‌ی کوله‌پشتی (Knapsack)
برای مدلسازی سوال، به مسئله کوله پشتی و حل آن با روش برنامه نویسی پویا، 
هر یال را به‌عنوان یک «آیتم» در نظر می‌گیریم:

وزن آیتم = هزینه یال

ارزش آیتم = ارزش جادویی یال

### تعریف آرایه‌ی DP
یک آرایه‌ی یک‌بعدی \(dp\) با طول \(b+1\) تعریف می‌کنیم:

$dp_j$:
 بیشینه ارزش جادویی قابل دستیابی با مجموع هزینه‌ی دقیقاً j

مقداردهی اولیه:

  مقدار اندیس صفرم آرایه برابر صفر و بقیه مقادیر آرایه برابر -1 است.

### به روز رسانی آرایه dp

برای هر راس $i$ و هزینه $j$ به صورت معکوس بر روی آرایه dp حرکت کرده و شرط زیر را مورد بررسی قرار می دهیم.

$$ 1 \le i \le n $$
$$ b \le j \le cost[i] $$

اگر $dp$ اندیس مورد نیاز پیش از این آپدیت شده باشد: 

$$ dp[j-cost[i]] ≠ -1$$

آنگاه:

```python3
   dp[j] = max(dp[j], dp[j-cost[i]] + magic[i])
```

لازم به ذکر است که متغیر `ans` نیز که دارای بیشینه مقدار موجود در آرایه dp است، را نیز در هممین حین به روز رسانی می کنیم.
 

## پیچیدگی زمان و حافظه

**پیچیدگی زمان**:

$$O(n \cdot b)$$

**پیچیدگی حافظه**:

$$O(b)$$

### تعریف آرایه dp

برای حل مسئله از دو آرایه‌ی دوبعدی استفاده می‌کنیم:

آرایه `dp[i][j]` را تعریف می کنیم: بیشینه ارزش جادویی قابل دستیابی با در نظر گرفتن $i$ یال اول و بودجه $j$ 

آرایه `par[i][j]` را تعریف می کنیم: در حالت بهینه با بوجه $j$ و $i$ یال اول، آیا یال $i$ام برداشته می شود یا خیر؟!

### به روزرسانی dp و par

در `dp[i][j]` می توانیم یال $i$ ام را برنداریم و به حالت `dp[i-1][j]` برسیم و اگر یال $i$ ام را برداریم، به حالت `dp[i-1][j-cost[i]]` می رسیم و ارزشمان برابر `dp[i-1][j-cost[i]] + magic[i]` می شود.

اگر حالت دوم بهینه بود، `par[i][j]` برابر $True$ قرار می دهیم و در غیر اینصورت برابر $False$

## بازیابی جواب (Backtracking)
پس از پر شدن جدول:
1. شروع از `i = m` و `j = b`  
2. به‌صورت معکوس تا `i = 1`:
   - اگر `par[i][j] == True`:
     - یال `i` را به پاسخ اضافه می‌کنیم (`ans.append(edges[i])`)
     - بودجه‌ی باقی‌مانده را کاهش می‌دهیم:  
       $$
         j \leftarrow j - cost[i]
       $$
   - `i` را یک واحد کم می‌کنیم  

در پایان، `ans` شامل لیست یال‌های انتخابی با بیشینه‌ی ارزش جادویی است.

## پیچیدگی زمانی و حافظه

**پیچیدگی زمان:**  

$$O(m \times b)$$

  (دو حلقه‌ی تو در تو روی یال‌ها و بودجه)

**پیچیدگی حافظه:**

$$O(m \times b)$$
  
برای نگهداری دو آرایه‌ی `dp` و `par`

