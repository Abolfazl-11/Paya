# 2. گراف جادویی

## خواسته سوال
در این مسأله یک گراف بدون دور (جنگل) با $n$ راس داریم که هر راس دو مقدار «هزینه» و «ارزش جادویی» دارد. باید زیرمجموعه‌ای از رئوس را طوری انتخاب کنیم که:
- مجموع هزینه‌های رئوس انتخابی از حد $b$ بیشتر نشود.
- زیر‌گراف حاصل از رئوس انتخابی همچنان جنگل (بدون دور) باقی بماند.
- مجموع ارزش جادویی رئوس انتخابی حداکثر شود.

**ورودی‌ها:**
- یک عدد صحیح `n`
- لیستی از `n` عدد که نمایانگر هزینه هر راس `cost`
- لیست `n` عضوی `magic` که حاوی ارزش جادویی هر راس است.
- یک عدد صحیح `b` (حداکثر بودجه مجاز)  

**خروجی:**
- بیشینه مجموع ارزش جادویی ممکن زیرمجموعه‌ای از رئوس با مجموع هزینه کمتر مساوی `b`

## راه حل

### ۱. مدل‌سازی به‌صورت مسئله‌ی کوله‌پشتی (Knapsack)
هر راس را به‌عنوان یک «آیتم» در نظر می‌گیریم:
- وزن آیتم = هزینه راس  
- ارزش آیتم = ارزش جادویی راس

### ۲. تعریف آرایه‌ی DP
یک آرایه‌ی یک‌بعدی \(dp\) با طول \(b+1\) تعریف می‌کنیم:

dp[j] = بیشینه ارزش جادویی قابل دستیابی با مجموع هزینه‌ی دقیقاً j

مقداردهی اولیه:

  مقدار اندیس صفرم آرایه برابر صفر و بقیه مقادیر آرایه برابر -1 است.

### ۳. به روز رسانی آرایه dp

برای هر راس $i$ و هزینه $j$ به صورت معکوس بر روی آرایه dp حرکت کرده و شرط زیر را مورد بررسی قرار می دهیم.

$$ 1 \le i \le n $$
$$ b \le j \le cost[i] $$

اگر $dp$ اندیس مورد نیاز پیش از این آپدیت شده باشد: 

$$ dp[j-cost[i]] ≠ -1$$

آنگاه:

```python3
   dp[j] = max(dp[j], dp[j-cost[i]] + magic[i])
```

لازم به ذکر است که متغیر `ans` نیز که دارای بیشینه مقدار موجود در آرایه dp است، را نیز در هممین حین به روز رسانی می کنیم.
 

## پیچیدگی زمانی و حافظه
- پیچیدگی زمانی: O(n × b)  
- پیچیدگی حافظه: O(b)  
