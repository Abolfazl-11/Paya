
# 🚀 نسخه بهینه الگوریتم کوله‌پشتی با فضای \( \mathcal{O}(B) \)

در این بخش، نسخه‌ای از الگوریتم کوله‌پشتی ۰/۱ را بررسی می‌کنیم که با استفاده از فضای بهینه، به جای استفاده از آرایه دوبعدی \( dp[i][j] \)، فقط از یک آرایه یک‌بعدی \( dp[j] \) استفاده می‌کند.

---

## 🧠 ایده اصلی

در الگوریتم کوله‌پشتی ۰/۱ کلاسیک، ما برای هر آیتم و هر بودجه ممکن، مقدار بهینه را نگهداری می‌کنیم. اما واقعیت این است که برای محاسبه `dp[i][j]` تنها به `dp[i-1][j - cost[i]]` نیاز داریم. پس می‌توانیم با نگهداری فقط یک ردیف، فضای مصرفی را از \( \mathcal{O}(n \cdot B) \) به \( \mathcal{O}(B) \) کاهش دهیم.

---

## ✨ پیاده‌سازی

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

int32_t main() {
    int n;
    cin >> n;

    vector<int> cost(n + 1), magic(n + 1);
    for (int i = 1; i < n; i++) cin >> cost[i];
    for (int i = 1; i < n; i++) cin >> magic[i];

    int B;
    cin >> B;

    vector<int> dp(B + 1, -1);
    dp[0] = 0; // حالت پایه: بدون انتخاب یال، ارزش 0

    int ans = 0;
    for (int i = 1; i < n; i++) {
        for (int j = B; j >= cost[i]; j--) {
            if (dp[j - cost[i]] != -1) {
                dp[j] = max(dp[j], dp[j - cost[i]] + magic[i]);
                ans = max(ans, dp[j]);
            }
        }
    }

    cout << ans << "\n";
}
```

---

## 🧮 چرا از عقب به جلو پیمایش می‌کنیم؟

اگر به صورت افزایشی از 0 به B برویم، ممکن است مقادیر `dp[j]` که در همین iteration به‌روز شده‌اند، دوباره برای `dp[j + cost[i]]` استفاده شوند. این باعث می‌شود که یال بیش از یک‌بار انتخاب شود، که خلاف منطق کوله‌پشتی ۰/۱ است. برای جلوگیری از این مشکل، باید از `B` به `cost[i]` به عقب برویم.

---

## ⏱️ پیچیدگی زمانی و فضایی

- **زمان**: \( \mathcal{O}(n \cdot B) \) — مثل نسخه‌ی اصلی
- **فضا**: \( \mathcal{O}(B) \) — بهینه‌شده با حذف یک بعد از آرایه

---

## ✅ نتیجه‌گیری

با تغییر آرایه dp از دوبعدی به یک‌بعدی، می‌توان فضای مصرفی الگوریتم کوله‌پشتی را بدون کاهش سرعت بهینه کرد. این تکنیک بسیار مفید است، به‌ویژه وقتی که مقدار `n` یا `B` زیاد باشد.
