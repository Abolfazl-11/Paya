
# 🚀 الگوریتم کوله‌پشتی

در این بخش، نسخه‌ای از الگوریتم کوله‌پشتی ۰/۱ را بررسی می‌کنیم که با استفاده از فضای بهینه، به جای استفاده از آرایه دوبعدی \( dp[i][j] \)، فقط از یک آرایه یک‌بعدی \( dp[j] \) استفاده می‌کند.

---

## 🧠 ایده اصلی

در الگوریتم کوله‌پشتی ۰/۱ کلاسیک، ما برای هر آیتم و هر بودجه ممکن، مقدار بهینه را نگهداری می‌کنیم. اما واقعیت این است که برای محاسبه `dp[i][j]` تنها به `dp[i-1][j - cost[i]]` نیاز داریم.

---

## 🧮 چرا از عقب به جلو پیمایش می‌کنیم؟

اگر به صورت افزایشی از 0 به B برویم، ممکن است مقادیر `dp[j]` که در همین iteration به‌روز شده‌اند، دوباره برای `dp[j + cost[i]]` استفاده شوند. این باعث می‌شود که یال بیش از یک‌بار انتخاب شود، که خلاف منطق کوله‌پشتی ۰/۱ است. برای جلوگیری از این مشکل، باید از `B` به `cost[i]` به عقب برویم.

---

## ⏱️ پیچیدگی زمانی و فضایی

- **زمان**:  O(n*B)
- **فضا**: O(B)

---

## ✅ نتیجه‌گیری

با استفاده از برنامه‌نویسی پویا این سوال را حل کردیم
