## پیدا کردن بلندترین مسیر بخش پذیر به P
ابتدا درخت را از راس 1 ریشه دار میکنیم برای این مسئله از dynamic programming استفاده می کنیم $dpD_{v, i}$ برابر است با بلندترین مسیری که از $v$ شروع شود در زیر درخت $v$ به سمت پایین حرکت کند و باقی مانده جمع وزن یال های این مسیر بر $P$، $i$ باشد که برای آپدیتش در DFS پس از اجرای الگوریتم روی بچه های $v$ و هنگام خروج روی همه ی بچه های $v$ فور می زنیم و مقدار $dpD_{v, i}$ را آپدیت می کنیم. $dpU_{v, i}$ را تعریف میکنیم طولانی ترین مسیری که از $v$ شروع شود از یال $v$ به پدرش $p$ استفاده کند و باقی مانده جمع وزن یال هایش بر $P$، $i$ باشد. برای آپدیتش در الگوریتم DFS وقتی که وارد یک راس مانند $v$ می شویم این دیپی را برای بچه هایش آپدیت میکنیم که به ازای هر $i$ وقتی که از یکی از بچه های $v$ مثل $u$ وارد $v$ میشویم یا همانجا میمانیم یا از یال $v$ به پدرش استفاده میکنیم که میشود $dpU_{v, i}$ و یا به بچه های دیگر $v$ میرویم که میشود $dpD_{u,i}$ و اینگونه $dpU_{u,i}$ را به ازای همه ی بچه های $v$ آپدیت می کنیم.
### پیچیدگی زمانی
چون از الگوریتم DFS استفاده می کنیم و در هر کدام به ازای همه ی $i$ ها از 1 تا $P$ فور میزنیم این کد از $O(P(n + m))$ است ولی چون گراف درخت است و $m = n - 1$ پس اوردر این کد میشود $O(Pn)$
اگر $P > n$ برای بهبود این کد میتوان از هر راس DFS زد و بلندترین مسیر بخش بذیر به $P$ را پیدا کرد اینگونه پیچیدگی زمان کد میشود $O(n^2)$ 