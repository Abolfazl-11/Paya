# بسم‌الله‌الرحمن‌الرحیم 🙂
## سوال چهارم
### خواسته سوال
بررسی اینکه آیا رشته‌ی ورودی `word` را می‌توان با دنبال‌کردن مسیرهای متوالی افقی و عمودی در ماتریس `board` پیدا کرد یا نه.

---

### پیچیدگی زمانی
`O(m × n × 4^l)`

که در آن:
- `m`: تعداد سطرهای ماتریس
- `n`: تعداد ستون‌های ماتریس
- `l`: طول رشته‌ی `word`

---

## مراحل اصلی برنامه

### ۱. دریافت ورودی از کاربر
- خواندن `m` و `n` از ورودی.
- دریافت `m` ردیف حاوی `n` کاراکتر برای ماتریس.
- دریافت رشته‌ی هدف `word`.

### ۲. اعتبارسنجی ورودی‌ها
- بررسی اینکه هر ردیف دقیقاً دارای `n` مقدار باشد.
- اگر مقدار ورودی مناسب نباشد، پیام `Invalid Input!` چاپ می‌شود و برنامه خاتمه می‌یابد.

### ۳. شمارش کاراکترها
- از دیکشنری برای شمارش تعداد کاراکترهای موجود در `board` و `word` استفاده می‌شود.
- بررسی اینکه آیا تعداد کاراکترهای لازم برای ساختن `word` در `board` وجود دارد یا نه.

### ۴. بهینه‌سازی ترتیب جستجو
- اگر کاراکتر اول `word` در ماتریس بیشتر از کاراکتر آخر باشد، `word` معکوس می‌شود تا مسیر جستجو کوتاه‌تر شود.

### ۵. آماده‌سازی نسخه‌ی قابل تغییر از ماتریس
- با استفاده از `[:]` یک کپی از هر ردیف ساخته می‌شود تا بتوانیم سلول‌ها را در حین جستجو موقتاً تغییر دهیم.

---

## تابع DFS برای جستجوی مسیر

```python
def dfs(i, j, k):
    اگر k برابر طول کلمه باشد:
        بازگرداندن True
    
    اگر خارج از محدوده باشیم یا کاراکتر تطابق نداشته باشد:
        بازگرداندن False

    ذخیره مقدار فعلی سلول، و تنظیم آن به None برای جلوگیری از بازدید مجدد.

    اجرای DFS در چهار جهت:
        بالا، پایین، چپ، راست

    اگر هر مسیر موفق باشد، بازگرداندن True
    در غیر این‌صورت بازگرداندن مقدار سلول و بازگرداندن False
```

---

## اجرای جستجوی نهایی
- برای هر سلول از ماتریس که برابر با حرف اول کلمه باشد:
    - اجرای DFS برای بررسی وجود مسیر کامل
    - اگر مسیر پیدا شود، چاپ `True` و خاتمه برنامه
- اگر هیچ مسیر درستی پیدا نشد، چاپ `False`

---